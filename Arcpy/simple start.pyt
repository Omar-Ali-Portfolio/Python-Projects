# -*- coding: utf-8 -*-# Omar Ali# 2/27/26## Python Toolbox - Clip Buffer Population Tool# This tool makes a buffer around point features, clips polygons using that buffer,# joins a population table, and calculates what percent of the population is inside# the buffer distance.import arcpyclass Toolbox:    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Toolbox"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [Tool]class Tool:    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Simple start"        self.description = "This is my first python toolbox."    def getParameterInfo(self):        """Define the tool parameters."""        # These are the inputs/outputs you see in the tool window in ArcGIS Pro.        # I set them up here so the user can pick layers, fields, and tables.        in_features_point = arcpy.Parameter(            displayName="Input point Features",            name="in_feature_point",            datatype="GPFeatureLayer",            parameterType="Required",            direction="Input")        in_features_point.filter.list = ["Point"]        # Buffer distance in miles (how far out from the points)        in_buffer_distance = arcpy.Parameter(            displayName="Buffer radius in miles",            name="in_buffer_distance",            datatype="GPDouble",            parameterType="Required",            direction="Input")        in_buffer_distance.value = 1        # Polygons that will get clipped by the buffer        in_features_polygon = arcpy.Parameter(            displayName="Input polygon features",            name="in_features_polygon",            datatype="GPFeatureLayer",            parameterType="Required",            direction="Input")        in_features_polygon.filter.list = ['Polygon']        # Area field from the polygon layer (used later for the proportional calc)        in_area_field = arcpy.Parameter(            displayName='Polygon old area field',            name='in_area_field',            datatype='Field',            parameterType='Required',            direction='Input')        in_area_field.parameterDependencies = [in_features_polygon.name]        # Join field from polygon layer (should match the join field in the table)        in_join_field = arcpy.Parameter(            displayName='Polygon join field',            name='in_join_field',            datatype='Field',            parameterType='Required',            direction='Input')        in_join_field.parameterDependencies = [in_features_polygon.name]        # Table that has population data        in_population_table = arcpy.Parameter(            displayName='Population table',            name='in_population_table',            datatype='GPTableView',            parameterType='Required',            direction='Input')        # Join field from the table        in_table_join_field = arcpy.Parameter(            displayName='Table join field',            name='in_table_join_field',            datatype='Field',            parameterType='Required',            direction='Input')        in_table_join_field.parameterDependencies = [in_population_table.name]        # Population field in the table (the actual population numbers)        in_table_population_field = arcpy.Parameter(            displayName='Population field',            name='in_table_population_field',            datatype='Field',            parameterType='Required',            direction='Input')        in_table_population_field.parameterDependencies = [in_population_table.name]        # Output feature class (final clipped polygons with calculations)        out_features_clip = arcpy.Parameter(            displayName="Output",            name='out_features',            datatype='GPFeatureLayer',            parameterType='Required',            direction='Output')        # Defaults just make it faster to test for the lab data        in_features_point.value         = 'public_library_shp'        in_features_polygon.value       = 'trt00_shp'        in_area_field.value             = 'Area'        in_join_field.value             = 'STFID2'        in_population_table.value       = 'population'        in_table_join_field.value       = 'GEO_ID'        in_table_population_field.value = 'P001001'        params = [in_features_point,            in_buffer_distance,            in_features_polygon,            in_area_field,            in_join_field,            in_population_table,            in_table_join_field,            in_table_population_field,            out_features_clip        ]        return params    def isLicensed(self):        """Set whether the tool is licensed to execute."""        return True    def updateParameters(self, parameters):        return    def updateMessages(self, parameters):        return    def execute(self, parameters, messages):        # Grab values from the tool window (same order as params above)        in_features_point = parameters[0].valueAsText        in_buffer_distance = parameters[1].value        in_features_polygon = parameters[2].valueAsText        in_area_field = parameters[3].valueAsText        in_join_field = parameters[4].valueAsText        in_population_table = parameters[5].valueAsText        in_table_join_field = parameters[6].valueAsText        in_table_population_field = parameters[7].valueAsText        out_features_clip = parameters[8].valueAsText        # step 1        # Make a buffer around the points using the mile distance.        out_features_buffer = arcpy.env.scratchGDB + '/buffers'        if arcpy.Exists(out_features_buffer):            arcpy.management.Delete(out_features_buffer)        arcpy.analysis.Buffer(in_features_point, out_features_buffer, f'{in_buffer_distance} Mile')        # step 2        # Clip polygons so we only keep what falls inside the buffer.        arcpy.analysis.Clip(in_features_polygon, out_features_buffer, out_features_clip, '')        arcpy.AddMessage(f'''Here are the specified -            + Parameter 1: {in_features_point}            + Parameter 2: {in_buffer_distance}''')        # Step 3. Joining fields        # Join population values from the table onto the clipped polygons.        arcpy.management.JoinField(out_features_clip, in_join_field, in_population_table, in_table_join_field, [in_table_population_field])        # Step 4. Adding a new field        # New field to store the population adjusted for the clipped area.        new_field_name = "proportional_pop"        arcpy.management.AddField(out_features_clip, new_field_name, "float", field_precision=10, field_scale=2)        # Step 5. Calculating the new field        # proportional_pop = population * (clipped_area / original_area)        in_new_area_field = 'Shape_Area'        formula = f'!{in_table_population_field}! * !{in_new_area_field}! / !{in_area_field}!'        arcpy.management.CalculateField(out_features_clip, new_field_name, formula, "PYTHON3")        # Step 5. Get the percent        # Total population (from the original table)        cursor = arcpy.da.SearchCursor(in_population_table, [in_table_population_field])        total = 0        for row in cursor:            total += row[0]        # Population inside the buffer (sum of proportional_pop)        cursor = arcpy.da.SearchCursor(out_features_clip, [new_field_name])        sub_total = 0        for row in cursor:            sub_total += row[0]        # Step 6. Message        # Print the final percent inside the buffer.        arcpy.AddMessage(f'''The percent of population in {in_buffer_distance} mile(s) is {100*sub_total/total:.2f}%.''')        return    def postExecute(self, parameters):        return